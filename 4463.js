(self.webpackChunkcb_wallet_extension=self.webpackChunkcb_wallet_extension||[]).push([[4463,9269],{51587:(e,t,s)=>{"use strict";s.d(t,{bitcoinService:()=>a,dogecoinService:()=>i,litecoinService:()=>r});var n=s(68477),o=s(19269);const a=new o._i({blockchainSymbol:"BTC"}),r=new o.dP({blockchainSymbol:"LTC"}),i=new o.qO({blockchainSymbol:"DOGE"});Promise.allSettled||(0,n.shim)()},74996:(e,t,s)=>{"use strict";s.d(t,{E:()=>a});var n=s(67612),o=s.n(n);function a(e,t){let s;try{s=o().address.fromBech32(e)}catch{return!1}return s.prefix===t.bech32&&0===s.version}},19269:(e,t,s)=>{"use strict";s.d(t,{_i:()=>f,qO:()=>m,dP:()=>k,deriveLegacyAddressFromXpubKey:()=>c,deriveSegwitAddressFromXpubKey:()=>i});var n=s(67612),o=s.n(n);async function a(e){const{HDKey:t}=await Promise.resolve().then(s.bind(s,42114));return t.parseExtendedKey(e.xpubKey).derive(`${e.change?1:0}/${e.index}`).publicKey}var r=s(41655);async function i({blockchainSymbol:e,xpubKey:t,index:s,change:n,testnet:i}){const c=(0,r.N)(e,i),d=await a({xpubKey:t,index:s,change:n});return o().payments.p2wpkh({pubkey:d,network:c}).address}async function c({blockchainSymbol:e,xpubKey:t,index:s,change:n,testnet:i}){const c=(0,r.N)(e,i),d=await a({xpubKey:t,index:s,change:n});return o().payments.p2pkh({pubkey:d,network:c}).address}var d=s(68583),l=s(74996),h=s(68758),u=s(40705);class b{constructor(e){this.blockchainSymbol=e.blockchainSymbol}async isAddressValid(e){return(0,d.p)({blockchainSymbol:this.blockchainSymbol,address:e.address,testnet:e.testnet})}async signTransaction(e){return this.sign(e.privateKeys,e.coinSelection,e.testnet)}async submitSignedTransaction(e){const t=await(0,h.T)({endpoint:"/v1/submitSignedTransaction",blockchainSymbol:this.blockchainSymbol,body:{data:e.signedTxData.toString("hex"),testnet:e.testnet},options:{isTextResponse:!0}});if(!(0,u.Lo)(t.body)||0===t.body.length)throw new Error("unexpected response")}}var y=s(1048).Buffer;class f extends b{async signTransactionAsync(e,t,s,n){const{inputs:a,outputs:i}=s,c=(0,r.N)(this.blockchainSymbol,n),h={},u=new(o().TransactionBuilder)(c);for(const e of a){const{address:t}=e;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:t,testnet:n});const s=(0,l.E)(t,c);h[t]=s;const o=4294967294;s?u.addInput(e.hash,e.index,o,e.script):u.addInput(e.hash,e.index,o)}for(const e of i){const{address:t}=e;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:t,testnet:n}),u.addOutput(t,e.value.toNumber())}await(async()=>{for(let s=0;s<a.length;s++){const n=a[s],{publicKey:o,derivationPath:r}=e[n.address];if(!y.isBuffer(o))throw new Error(`public key for ${n.address} not found`);h[n.address]?await u.signAsync(s,o,r,t,void 0,void 0,n.value.toNumber()):await u.signAsync(s,o,r,t)}})();const b=u.build();return{data:b.toBuffer(),hash:y.from(b.getHash().reverse()).toString("hex")}}sign(e,t,s){const{inputs:n,outputs:a}=t,i={},c=(0,r.N)(this.blockchainSymbol,s),h=new(o().TransactionBuilder)(c);for(const e of n){const{address:t}=e;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:t,testnet:s});const n=(0,l.E)(t,c);i[t]=n,n?h.addInput(e.hash,e.index,4294967293,e.script):h.addInput(e.hash,e.index,4294967293)}for(const e of a){const{address:t}=e;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:t,testnet:s}),h.addOutput(t,e.value.toNumber())}n.forEach(((t,s)=>{const n=e[t.address];if(!y.isBuffer(n))throw new Error(`private key for ${t.address} not found`);const a=o().ECPair.fromPrivateKey(n,{network:c});i[t.address]?h.sign(s,a,void 0,void 0,t.value.toNumber()):h.sign(s,a)}));const u=h.build();return{data:u.toBuffer(),hash:y.from(u.getHash().reverse()).toString("hex")}}}var p=s(1048).Buffer;class m extends b{async signTransaction(e){return this.sign(e.privateKeys,e.coinSelection,e.testnet)}async signTransactionAsync(e,t,s,n){const{inputs:a,outputs:i}=s,c=(0,r.N)(this.blockchainSymbol,n),l=new(o().TransactionBuilder)(c);l.setVersion(1);for(const e of a){const{address:t}=e;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:t,testnet:n}),l.addInput(e.hash,e.index)}for(const e of i){const{address:t}=e;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:t,testnet:n}),l.addOutput(t,e.value.toNumber())}await(async()=>{for(let s=0;s<a.length;s++){const n=a[s],{publicKey:o,derivationPath:r}=e[n.address];if(!p.isBuffer(o))throw new Error(`public key for ${n.address} not found`);await l.signAsync(s,o,r,t)}})();const h=l.build();return{data:h.toBuffer(),hash:p.from(h.getHash().reverse()).toString("hex")}}sign(e,t,s){const{inputs:n,outputs:a}=t,i=(0,r.N)(this.blockchainSymbol,s),c=new(o().TransactionBuilder)(i);c.setVersion(1);for(const e of n){const{address:t}=e;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:t,testnet:s}),c.addInput(e.hash,e.index)}for(const e of a){const{address:t}=e;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:t,testnet:s}),c.addOutput(t,e.value.toNumber())}n.forEach(((t,s)=>{const n=e[t.address];if(!p.isBuffer(n))throw new Error(`private key for ${t.address} not found`);const a=o().ECPair.fromPrivateKey(n,{network:i});c.sign(s,a)}));const l=c.build();return{data:l.toBuffer(),hash:p.from(l.getHash().reverse()).toString("hex")}}}s(27175),s(32212),s(80043),s(48985),s(51847),s(23062);class k extends f{}},86973:()=>{}}]);
//# sourceMappingURL=4463.js.map