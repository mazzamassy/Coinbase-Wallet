"use strict";(self.webpackChunkcb_wallet_extension=self.webpackChunkcb_wallet_extension||[]).push([[9269],{74996:(t,s,e)=>{e.d(s,{E:()=>a});var n=e(67612),o=e.n(n);function a(t,s){let e;try{e=o().address.fromBech32(t)}catch{return!1}return e.prefix===s.bech32&&0===e.version}},19269:(t,s,e)=>{e.d(s,{_i:()=>f,qO:()=>m,dP:()=>k,deriveLegacyAddressFromXpubKey:()=>c,deriveSegwitAddressFromXpubKey:()=>i});var n=e(67612),o=e.n(n);async function a(t){const{HDKey:s}=await Promise.resolve().then(e.bind(e,42114));return s.parseExtendedKey(t.xpubKey).derive(`${t.change?1:0}/${t.index}`).publicKey}var r=e(41655);async function i({blockchainSymbol:t,xpubKey:s,index:e,change:n,testnet:i}){const c=(0,r.N)(t,i),d=await a({xpubKey:s,index:e,change:n});return o().payments.p2wpkh({pubkey:d,network:c}).address}async function c({blockchainSymbol:t,xpubKey:s,index:e,change:n,testnet:i}){const c=(0,r.N)(t,i),d=await a({xpubKey:s,index:e,change:n});return o().payments.p2pkh({pubkey:d,network:c}).address}var d=e(68583),h=e(74996),u=e(68758),l=e(40705);class b{constructor(t){this.blockchainSymbol=t.blockchainSymbol}async isAddressValid(t){return(0,d.p)({blockchainSymbol:this.blockchainSymbol,address:t.address,testnet:t.testnet})}async signTransaction(t){return this.sign(t.privateKeys,t.coinSelection,t.testnet)}async submitSignedTransaction(t){const s=await(0,u.T)({endpoint:"/v1/submitSignedTransaction",blockchainSymbol:this.blockchainSymbol,body:{data:t.signedTxData.toString("hex"),testnet:t.testnet},options:{isTextResponse:!0}});if(!(0,l.Lo)(s.body)||0===s.body.length)throw new Error("unexpected response")}}var y=e(1048).Buffer;class f extends b{async signTransactionAsync(t,s,e,n){const{inputs:a,outputs:i}=e,c=(0,r.N)(this.blockchainSymbol,n),u={},l=new(o().TransactionBuilder)(c);for(const t of a){const{address:s}=t;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:s,testnet:n});const e=(0,h.E)(s,c);u[s]=e;const o=4294967294;e?l.addInput(t.hash,t.index,o,t.script):l.addInput(t.hash,t.index,o)}for(const t of i){const{address:s}=t;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:s,testnet:n}),l.addOutput(s,t.value.toNumber())}await(async()=>{for(let e=0;e<a.length;e++){const n=a[e],{publicKey:o,derivationPath:r}=t[n.address];if(!y.isBuffer(o))throw new Error(`public key for ${n.address} not found`);u[n.address]?await l.signAsync(e,o,r,s,void 0,void 0,n.value.toNumber()):await l.signAsync(e,o,r,s)}})();const b=l.build();return{data:b.toBuffer(),hash:y.from(b.getHash().reverse()).toString("hex")}}sign(t,s,e){const{inputs:n,outputs:a}=s,i={},c=(0,r.N)(this.blockchainSymbol,e),u=new(o().TransactionBuilder)(c);for(const t of n){const{address:s}=t;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:s,testnet:e});const n=(0,h.E)(s,c);i[s]=n,n?u.addInput(t.hash,t.index,4294967293,t.script):u.addInput(t.hash,t.index,4294967293)}for(const t of a){const{address:s}=t;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:s,testnet:e}),u.addOutput(s,t.value.toNumber())}n.forEach(((s,e)=>{const n=t[s.address];if(!y.isBuffer(n))throw new Error(`private key for ${s.address} not found`);const a=o().ECPair.fromPrivateKey(n,{network:c});i[s.address]?u.sign(e,a,void 0,void 0,s.value.toNumber()):u.sign(e,a)}));const l=u.build();return{data:l.toBuffer(),hash:y.from(l.getHash().reverse()).toString("hex")}}}var p=e(1048).Buffer;class m extends b{async signTransaction(t){return this.sign(t.privateKeys,t.coinSelection,t.testnet)}async signTransactionAsync(t,s,e,n){const{inputs:a,outputs:i}=e,c=(0,r.N)(this.blockchainSymbol,n),h=new(o().TransactionBuilder)(c);h.setVersion(1);for(const t of a){const{address:s}=t;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:s,testnet:n}),h.addInput(t.hash,t.index)}for(const t of i){const{address:s}=t;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:s,testnet:n}),h.addOutput(s,t.value.toNumber())}await(async()=>{for(let e=0;e<a.length;e++){const n=a[e],{publicKey:o,derivationPath:r}=t[n.address];if(!p.isBuffer(o))throw new Error(`public key for ${n.address} not found`);await h.signAsync(e,o,r,s)}})();const u=h.build();return{data:u.toBuffer(),hash:p.from(u.getHash().reverse()).toString("hex")}}sign(t,s,e){const{inputs:n,outputs:a}=s,i=(0,r.N)(this.blockchainSymbol,e),c=new(o().TransactionBuilder)(i);c.setVersion(1);for(const t of n){const{address:s}=t;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:s,testnet:e}),c.addInput(t.hash,t.index)}for(const t of a){const{address:s}=t;(0,d.j)({blockchainSymbol:this.blockchainSymbol,address:s,testnet:e}),c.addOutput(s,t.value.toNumber())}n.forEach(((s,e)=>{const n=t[s.address];if(!p.isBuffer(n))throw new Error(`private key for ${s.address} not found`);const a=o().ECPair.fromPrivateKey(n,{network:i});c.sign(e,a)}));const h=c.build();return{data:h.toBuffer(),hash:p.from(h.getHash().reverse()).toString("hex")}}}e(27175),e(32212),e(80043),e(48985),e(51847),e(23062);class k extends f{}}}]);
//# sourceMappingURL=9269.js.map